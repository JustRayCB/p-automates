\documentclass[a4paper, 12pt]{extarticle}

\input{preamble.tex} 


% Based on 'Fun Template 1', available at https://www.overleaf.com/latex/templates/fun-template-1/drwvdzsrpgzz


\begin{document}

%================= Settings front page =================
\titre{Rapport Informatique Fondamentale} %Titre du fichier .pdf
\UE{INFO-F302} %Nom de la UE
\sujet{Informatique Fondamentale} %Nom du sujet

\enseignant{E. \textsc{Filliot} \\ R. \textsc{Petit}}  %Nom des enseignants
% Use \\ TO BREAK LINE

\eleves{Hugo \textsc{Callens} \\ Rayan \textsc{Contuliano Bravo} \\ Ethan \textsc{Rogge}}
% \maketitle
\makemargins %Afficher les marges
\makefrontpage
% \maketoc

%=======================================================

% this is the orginal latex code of the template
% \input{example}

%================= Content =============================

%QUESTION 1
\section{Modélisation d'un automate déterministe en FNC} 
\label{sec:modelisation_d_automates_en_fnc_}

% Sachant qu'il existe les ensemble $P$ et $N$ qui représentent respectivement 
% les états acceptants et non-acceptants d'un automate, nous avons décidé de 
% modéliser un automate en FNC de la manière suivante :

Voici quelques notations utilisées dans la suite de ce rapport : 
\begin{itemize}[label=$\bullet$]
    \item $P$ représente l'ensemble des mots acceptés par l'automate 
    \item $N$ représente l'ensemble des mots non-acceptés par l'automate 
    \item $\Sigma$ représente l'alphabet de l'automate 
    \item $k$ représente le nombre au plus d'états de l'automate
\end{itemize}

\subsection{Choix des variables}
\label{sub:choix_des_variables}

\subsubsection{Etats}
\label{sec:etats}

\noindent L'ensemble $Q$ est défini comme suit : $Q = \{q_{0a}, q_{0na}, \dots, q_{la}, q_{lna} | l \le k\}$ contenant
ainsi $2k$ états dans $Q$ pour un automate à $k$ états. Les variables $q_i$ peuvent être définies comme suit : 
\begin{itemize}[label=$\bullet$]
    \item $q_{ia} = 1$ si l'état $i$ est acceptant et donc $q_{ina} = 0$.
    \item $q_{ina} = 1$ si l'état $i$ est non-acceptant et donc $q_{ia} = 0$.
\end{itemize}

\subsubsection{Transitions} 
\label{sec:transitions} 

\noindent L'ensemble $\delta$ est défini comme suit : $\delta = \{d_{i, l, j} | i, j \in Q, l \in \Sigma\}$, représentant
l'ensemble des transitions de l'automate. Les variables $d_{i, l, j}$ peuvent être définies comme suit : 
\begin{itemize}[label=$\bullet$]
    \item $d_{i, l, j} = 1$ si la transition avec la lettre $l$ existe entre l'état $i$ et l'état $j$.
    \item $d_{i, l, j} = 0$ si la transition avec la lettre $l$ n'existe pas entre l'état $i$ et l'état $j$.
\end{itemize} 


\subsubsection{Exécutions}
\label{sec:executions}

\noindent L'ensemble $E$ est défini comme suit : $E = \{e_{m, i, t} | i \in Q, t \in \{-1,\dots,\text{len}(m)\}\, m \in P \cup N\}$,
représentant l'ensemble des exécutions de l'automate. Les variables $e_{m, i, t}$ peuvent être définies comme suit :
\begin{itemize}[label=$\bullet$]
    \item $e_{m, i, t} = 1$ si l'automate est dans l'état $i$ après avoir lu les $t$ premières lettres du mot $m$.
    \item $e_{m, i, t} = 0$ si l'automate n'est pas dans l'état $i$ après avoir lu les $t$ premières lettres du mot $m$.
\end{itemize}


\subsection{Contraintes} % (fold)
\label{sub:contraintes}

\begin{enumerate}
    %1
    \item Il y a un unique état initial :
    \begin{equation*}
        q_{0a} \vee q_{0na}
    \end{equation*}
    %2
    \item Un état est exclusivement acceptant ou non-acceptant :
    \begin{equation*}
        \bigwedge_{\substack{q\in Q \\ i\in \{1,\dots,k\}}} q_{ia} \rightarrow \neg q_{ina}\equiv
        \bigwedge_{\substack{q\in Q \\ i\in \{1,\dots,k\}}} \neg q_{ia} \vee \neg q_{ina}
    \end{equation*}
    %3
    \item Chaque état a au plus une transition par lettre de l'alphabet :
    \begin{equation*}
        \bigwedge_{\substack{l\in \Sigma\\i,j,q \in Q}} d_{i,l,j} \rightarrow \neg d_{i,l,q}\equiv
        \bigwedge_{\substack{l\in \Sigma\\i,j,q \in Q}}\neg d_{i,l,j} \vee \neg d_{i,l,q}
    \end{equation*}
    %4
    \item Un état $i$ est acceptant s'il existe une exécution d'un mot $m$ de $P$ qui se termine sur l'état $i$ à l'étape $t=len(m)$ :
    \begin{equation*}
        \bigwedge_{\substack{t=len(m)\\q \in Q\\ m \in P\\ i \in \{1,\dots,k\}}} e_{m,i,t} \rightarrow q_{ia} \equiv
        \bigwedge_{\substack{t=len(m)\\q \in Q\\ m \in P\\ i \in \{1,\dots,k\}}} \neg e_{m,i,t} \vee q_{ia}
    \end{equation*}
    %5
    \item Si on a une exécution pour le mot $m$ à l'étape $t$ sur l'état $i$ et une transition de $i$ vers $j$ pour la lettre l,
    alors, on a une exécution pour le mot $m$ à l'étape $t+1$ sur l'état $j$ :
    \begin{equation*}
        \bigwedge_{\substack{i,j \in Q\\l \in \Sigma\\m \in P\\t \in \{0,\dots,len(m)\}\\l=m[t]}} (e_{m,i,t} \wedge d_{i,l,j} \rightarrow e_{m,j,t+1}) \equiv
        \bigwedge_{\substack{i,j \in Q\\l \in \Sigma\\m \in P\\t \in \{0,\dots,len(m)\}\\l=m[t]}} (\neg e_{m,i,t} \vee \neg d_{i,l,j} \vee e_{m,j,t+1})
    \end{equation*}
    %6
    \item Si on a une exécution pour le mot $m$ à l'étape $t$ sur l'état $i$ et une exécution pour le même mot $m$ à l'étape $t+1$ sur l'état $j$,
    alors, il existe une transition de $i$ vers $j$ pour la lettre $l$ :
    \begin{equation*}
        \bigwedge_{\substack{i,j \in Q\\l \in \Sigma\\m \in P\\t \in \{0,\dots,len(m)\}\\l=m[t]}} (e_{m,i,t} \wedge e_{m,j,t+1} \rightarrow d_{i,l,j})\equiv
        \bigwedge_{\substack{i,j \in Q\\l \in \Sigma\\m \in P\\t \in \{0,\dots,len(m)\}\\l=m[t]}} (\neg e_{m,i,t} \vee \neg e_{m,j,t+1} \vee d_{i,l,j})
    \end{equation*}
    %7
    \item Toutes les exécutions sur les mots de N doivent se terminer sur un état non-acceptant :
    \begin{equation*}
        \bigwedge_{\substack{m \in N\\i \in \{1,\dots,k\}\\t=len(m)}\\q\in Q} e_{m,i,t} \rightarrow q_{ina}\equiv
        \bigwedge_{\substack{m \in N\\i \in \{1,\dots,k\}\\t=len(m)}\\q\in Q} \neg e_{m,i,t} \vee q_{ina}
    \end{equation*}
    %8
    \item Toutes les exécutions sur les mots de P doivent exister :
    \begin{equation*}
        \bigwedge{\substack{m\in P}}\bigvee_{\substack{t\in\{0,\dots,len(word)\}\\i\in \{1,\dots,k\}}} e_{m,i,t+1}
    \end{equation*}
    %9
    \item Toutes les exécutions doivent commencer à l'état initial :
    \begin{equation*}
        \bigwedge_{\substack{m\in P\cup N}} e_{m,1,0}
    \end{equation*}
\end{enumerate}

%QUESTION 3
\section{Algorithme de minimisation d'un automate déterministe}
\label{sec:algo_minimisation}
\noindent Afin de minimiser le nombre d'états d'un automate fini sur $\Sigma$, une approche itérative est utilisée en considérant :
\begin{equation*}
    k\in\{0,\dots,\infty\}
\end{equation*}
Etant donné que l'automate est fini, il existe un nombre fini d'états, éliminant ainsi la nécessité d'une borne supérieure.
Pour chaque valeur de $k$, les contraintes précédemment définies (cf. \ref{sec:modelisation_d_automates_en_fnc_}) sont utilisées
dans le but de déterminer le $k$ minimal pour lequel le résultat n'est pas \texttt{None}.


%QUESTION 4
\section{Modélisation d'un automate déterministe complet en FNC} 
\label{sec:automate_deterministe_complet}
\noindent Il suffit de reprendre les contraintes précédentes (cf. \ref{sec:modelisation_d_automates_en_fnc_}) et d'ajouter la
contrainte suivante :
\begin{enumerate}
    \item Tous les états doivent avoir au moins une transition par lettre de l'alphabet :
    \begin{equation*}
        \bigwedge_{l \in \Sigma} \bigvee_{i,j\in Q} d_{i,l,j}
    \end{equation*}
\end{enumerate}
Du fait que nous avons au moins une transition par lettre de l'alphabet et au plus une transition par lettre de l'alphabet,
nous avons donc exactement une transition par lettre de l'alphabet pour chaque état, ce qui implique que l'automate est complet.


%QUESTION 5
\section{Modélisation d'un automate réversible en FNC}
\noindent Il suffit de rajouter aux contraintes précédentes (cf. \ref{sec:modelisation_d_automates_en_fnc_}) la contrainte suivante :
\begin{enumerate}
    \item S'il existe une transition de $i$ vers $j$ pour la lettre $l$, alors il n'existe pas de transition de $k$ vers $j$ pour la lettre $l$ :
    \begin{equation*}
        \bigwedge_{\substack{i,j \in Q\\l \in \Sigma}} d_{i,l,j} \rightarrow \neg d_{k,l,j}\equiv
        \bigwedge_{\substack{i,j \in Q\\l \in \Sigma}} \neg d_{i,l,j} \vee \neg d_{k,l,j}
    \end{equation*}
\end{enumerate}

\begin{figure}[H]
    \centering
    \begin{tikzpicture} [node distance = 2cm, on grid, auto]
        
        \node (q0) [state, draw=red] {$j$};
        \node (q1) [state, draw=red, above left = of q0] {$i$};
        \node (q2) [state, draw=red,below left = of q0] {$k$};
        
        \path [-stealth, thick, draw=red, fill=red]
        (q1) edge node {a}   (q0)
        (q2) edge node {a} (q0);
    \end{tikzpicture}
    \hspace{4cm}
    \begin{tikzpicture} [node distance = 2cm, on grid, auto]
        
        \node (q0) [state, draw=green] {$j$};
        \node (q1) [state, draw=green, above right = of q0] {$i$};
        \node (q2) [state, draw=green, below right = of q0] {$k$};
        
        \path [-stealth, thick, draw=green, fill=green]
        (q1) edge node {a}   (q0)
        (q2) edge node {b} (q0);
    \end{tikzpicture}
    \caption{A gauche nous voyons un automate non-réversible et à droite nous voyons un automate réversible}
\end{figure}
    
    %QUESTION 6
    \section{Modélisation d'un automate fini complet avec au plus $l$ états en FNC}
    \noindent Pour que l'automate fini complet ait au plus $l$ états, il suffit de rajouter aux contraintes précédentes (cf. \ref{sec:automate_deterministe_complet}) 
    la contrainte suivante (suivant le formalisme de la documentation de \href{https://pysathq.github.io/docs/html/api/solvers.html#pysat.solvers.Solver.add_atmost}{PySAT}):
    \begin{enumerate}
        \item Il y a au plus $l$ états acceptants :
        \begin{equation*}
            \sum_{i=0}^{k} q_{ia} \le l
        \end{equation*}
    \end{enumerate}
    Cette contrainte a été ajoutée au solveur \texttt{MiniCard}.
    %================= Bibliography ========================
    % \newpage
    % \phantomsection % Required if hyperref is used
    % \addcontentsline{toc}{section}{References} % Adding bibliography to table of contents
    % \printbibliography % Print the bibliography
    
    \end{document}