\documentclass[a4paper, 12pt]{extarticle}

\input{preamble.tex} 


% Based on 'Fun Template 1', available at https://www.overleaf.com/latex/templates/fun-template-1/drwvdzsrpgzz


\begin{document}

%================= Settings front page =================
\titre{Rapport Informatique Fondamentale} %Titre du fichier .pdf
\UE{INFO-F302} %Nom de la UE
\sujet{Informatique Fondamentale} %Nom du sujet

\enseignant{E. \textsc{Filliot} \\ R. \textsc{Petit}}  %Nom des enseignants
% Use \\ TO BREAK LINE

\eleves{Hugo \textsc{Callens} \\ Rayan \textsc{Contuliano Bravo} \\ Ethan \textsc{Rogge}}
% \maketitle
\makemargins %Afficher les marges
\makefrontpage
\maketoc


%=======================================================

% this is the orginal latex code of the template
% \input{example}

%================= Content =============================

%QUESTION 1
\section{Modélisation d'un automate déterministe en FNC } 
\label{sec:modelisation_d_automates_en_fnc_}

% Sachant qu'il existe les ensemble $P$ et $N$ qui représentent respectivement 
% les états acceptants et non-acceptants d'un automate, nous avons décidé de 
% modéliser un automate en FNC de la manière suivante :

Voici quelques notations utilisées dans la suite de ce rapport : 
\begin{itemize}[label=$\bullet$]
    \item $P$ représente l'ensemble des mots acceptés par l'automate 
    \item $N$ représente l'ensemble des mots non-acceptés par l'automate 
    \item $\Sigma$ représente l'alphabet de l'automate 
    \item $k$ représente le nombre au plus d'états de l'automate
\end{itemize}

\subsection{Choix des variables}
\label{sub:choix_des_variables}

\subsubsection{Etats}
\label{sec:etats}

\noindent L'ensemble $Q$ est défini comme suit : $Q = \{q_{1a}, q_{1na}, \dots, q_{ka}, q_{kna} | k\}$ contenant
ainsi $2k$ états dans $Q$ pour un automate à $k$ états. Les variables $q_i$ peuvent être définies comme suit : 
\begin{itemize}[label=$\bullet$]
    \item $q_{ia/na} = 1$ si l'état $i$ acceptant/non-acceptant est présent dans l'automate.
    \item $q_{ia/na} = 0$ si l'état $i$ acceptant/non-acceptant n'est pas présent dans l'automate.
\end{itemize}
Cette implémentation permet de représenter un automate avec au plus $k$ états. En effet, si l'état $i$ n'est pas présent dans l'automate, 
alors, les variables $q_{ia}$ et $q_{ina}$ sont toutes les deux égales à 0. 


\subsubsection{Transitions} 
\label{sec:transitions} 

\noindent L'ensemble $\Delta$ est défini comme suit : $\Delta = \{d_{i, l, j} | i, j \in Q, l \in \Sigma\}$, représentant
l'ensemble des transitions de l'automate. Les variables $d_{i, l, j}$ peuvent être définies comme suit : 
\begin{itemize}[label=$\bullet$]
    \item $d_{i, l, j} = 1$ si la transition avec la lettre $l$ existe entre l'état $i$ et l'état $j$.
    \item $d_{i, l, j} = 0$ si la transition avec la lettre $l$ n'existe pas entre l'état $i$ et l'état $j$.
\end{itemize} 


\subsubsection{Exécutions}
\label{sec:executions}

\noindent L'ensemble $E$ est défini comme suit : $E = \{e_{m, i, t} | i \in Q, t \in \{0,\dots,\text{len}(m)-1\}, m \in P \cup N\}$,
représentant l'ensemble des exécutions de l'automate. Les variables $e_{m, i, t}$ peuvent être définies comme suit :
\begin{itemize}[label=$\bullet$]
    \item $e_{m, i, t} = 1$ si l'automate est dans l'état $i$ après avoir lu les $t$ premières lettres du mot $m$.
    \item $e_{m, i, t} = 0$ si l'automate n'est pas dans l'état $i$ après avoir lu les $t$ premières lettres du mot $m$.
\end{itemize}


\subsection{Contraintes} % (fold)
\label{sub:contraintes}

\begin{enumerate}
    %1
    \item Il y a un unique état initial :
    \begin{equation*}
        \Phi_1=q_{0a} \vee q_{0na}
    \end{equation*}
    %2
    \item Un état est exclusivement acceptant ou non-acceptant :
    \begin{equation*}
        \Phi_2=\bigwedge_{\substack{q\in Q \\ i\in \{1,\dots,k\}}} q_{ia} \rightarrow \neg q_{ina}\equiv
        \bigwedge_{\substack{q\in Q \\ i\in \{1,\dots,k\}}} \neg q_{ia} \vee \neg q_{ina}
    \end{equation*}
    %3
    \item Chaque état a au plus une transition par lettre de l'alphabet :
    \begin{equation*}
        \Phi_3=\bigwedge_{\substack{l\in \Sigma\\i,j,q \in Q}} d_{i,l,j} \rightarrow \neg d_{i,l,q}\equiv
        \bigwedge_{\substack{l\in \Sigma\\i,j,q \in Q}}\neg d_{i,l,j} \vee \neg d_{i,l,q}
    \end{equation*}
    %4
    \item Un état $i$ est acceptant s'il existe une exécution d'un mot $m$ de $P$ qui se termine sur l'état $i$ à l'étape $t=len(m)$ :
    \begin{equation*}
        \Phi_4=\bigwedge_{\substack{t=len(m)\\q \in Q\\ m \in P\\ i \in \{1,\dots,k\}}} e_{m,i,t} \rightarrow q_{ia} \equiv
        \bigwedge_{\substack{t=len(m)\\q \in Q\\ m \in P\\ i \in \{1,\dots,k\}}} \neg e_{m,i,t} \vee q_{ia}
    \end{equation*}
    %5
    \item Si on a une exécution qui est sur l'état $i$ pour l'étape $t$ du mot $m$ et une transition de $i$ vers $j$ pour la lettre l,
    alors, on a une exécution pour le mot $m$ à l'étape $t+1$ sur l'état $j$ :
    \begin{equation*}
        \Phi_5=\bigwedge_{\substack{i,j \in Q\\l \in \Sigma\\m \in P\cup N\\t \in \{0,\dots,len(m)\}\\l=m[t]}} (e_{m,i,t} \wedge d_{i,l,j} \rightarrow e_{m,j,t+1}) \equiv
        \bigwedge_{\substack{i,j \in Q\\l \in \Sigma\\m \in P\cup N\\t \in \{0,\dots,len(m)\}\\l=m[t]}} (\neg e_{m,i,t} \vee \neg d_{i,l,j} \vee e_{m,j,t+1})
    \end{equation*}
    %6
    \item Si on a une exécution qui est sur l'état $i$ pour l'étape $t$ du mot $m$ et une exécution à l'étape $t+1$ pour le même mot $m$ qui se trouve sur l'état $j$,
    alors, il existe une transition de $i$ vers $j$ avec la lettre $l$ :
    \begin{equation*}
        \Phi_6=\bigwedge_{\substack{i,j \in Q\\l \in \Sigma\\m \in P\cup N\\t \in \{0,\dots,len(m)\}\\l=m[t]}} (e_{m,i,t} \wedge e_{m,j,t+1} \rightarrow d_{i,l,j})\equiv
        \bigwedge_{\substack{i,j \in Q\\l \in \Sigma\\m \in P\cup N\\t \in \{0,\dots,len(m)\}\\l=m[t]}} (\neg e_{m,i,t} \vee \neg e_{m,j,t+1} \vee d_{i,l,j})
    \end{equation*}
    %7
    \item Toutes les exécutions, qui existent, sur les mots de N doivent se terminer sur un état non-acceptant :
    \begin{equation*}
        \Phi_7=\bigwedge_{\substack{m \in N\\i \in \{1,\dots,k\}\\t=len(m)\\q\in Q}} e_{m,i,t} \rightarrow q_{ina}\equiv
        \bigwedge_{\substack{m \in N\\i \in \{1,\dots,k\}\\t=len(m)\\q\in Q}} \neg e_{m,i,t} \vee q_{ina}
    \end{equation*}
    %8
    \item Toutes les exécutions sur les mots de P doivent exister :
    \begin{equation*}
        \Phi_8=\bigwedge{\substack{m\in P}}\bigvee_{\substack{t\in\{0,\dots,len(word)\}\\i\in \{1,\dots,k\}}} e_{m,i,t+1}
    \end{equation*}
    %9
    \item Toutes les exécutions doivent commencer à l'état initial :
    \begin{equation*}
        \Phi_9=\bigwedge_{\substack{m\in P\cup N}} e_{m,1,0}
    \end{equation*}
\end{enumerate}
La formule en logique propositionelle finale est :
\begin{equation*}
    \Phi=\bigwedge_{i=1,\dots,9} \Phi_i
\end{equation*}

%QUESTION 3
\section{Algorithme de minimisation d'un automate déterministe}
\label{sec:algo_minimisation}
\noindent Afin de minimiser le nombre d'états d'un automate fini sur $\Sigma$, une approche dichotomique est utilisée en considérant :
\begin{enumerate}
    \item Recherche de la borne supérieure, donc un $k$ tel qu'avec $2^k$ états, la solution est trouvée.
    \item Recherche dichotomique entre $2^{(k-1)}$ et $2^k$ pour trouver le $k$ minimal pour lequel la solution est trouvée.
\end{enumerate}
Il suffit d'utiliser les contraintes précédemment définies (cf. \ref{sub:contraintes}) afin de trouver
l'automate minimal en nombre d'états.
\warningbox{La réduction d'un automate fini à $k$ états se fait dans le pire des cas en un automate à $k$ états. Cependant, il est 
question ici de générer un automate minimal et non pas de réduire un automate fini. C'est pourquoi une variable $\epsilon$
a été introduite, l'algorithme développé va tester pour un maximum de $2^{10}$ états s'il trouve un automate. En effet, il se peut que 
la méthode \texttt{get\_model()} ne renvoie jamais un automate si les paramètres donnés n'aboutissent pas à la création d'un automate 
déterministe.}

%QUESTION 4
\section{Modélisation d'un automate déterministe complet en FNC} 
\label{sec:automate_deterministe_complet}
\noindent Il suffit de reprendre les contraintes précédentes (cf. \ref{sub:contraintes}) et d'ajouter la
contrainte suivante :
\begin{enumerate}
    \item Tous les états doivent avoir au moins une transition par lettre de l'alphabet :
    \begin{equation*}
        \bigwedge_{l \in \Sigma} \bigvee_{i,j\in Q} d_{i,l,j}
    \end{equation*}
\end{enumerate}
Comme il y a au moins une transition par lettre de l'alphabet et au plus une transition par lettre de l'alphabet,
il y a donc exactement une transition par lettre de l'alphabet pour chaque état, ce qui implique que l'automate est complet.


%QUESTION 5
\section{Modélisation d'un automate réversible en FNC}
\noindent Il suffit de rajouter aux contraintes précédentes (cf. \ref{sub:contraintes}) la contrainte suivante :
\begin{enumerate}
    \item S'il existe une transition de l'état $i$ vers l'état $j$ pour la lettre $l$, alors il n'existe pas de transition de l'état $k$ vers l'état $j$ pour la lettre $l$ :
    \begin{equation*}
        \bigwedge_{\substack{i,j,k \in Q\\l \in \Sigma}} d_{i,l,j} \rightarrow \neg d_{k,l,j}\equiv
        \bigwedge_{\substack{i,j,k \in Q\\l \in \Sigma}} \neg d_{i,l,j} \vee \neg d_{k,l,j}
    \end{equation*}
\end{enumerate}
En effet, deux états ne peuvent pas avoir une transition vers le même état avec la même lettre car si on inverse le sens des transitions,
l'automate serait non-déterministe.

\begin{figure}[H]
    \centering
    \begin{tikzpicture} [node distance = 2cm, on grid, auto]
        
        \node (q0) [state, draw=red] {$j$};
        \node (q1) [state, draw=red, above left = of q0] {$i$};
        \node (q2) [state, draw=red,below left = of q0] {$k$};
        
        \path [-stealth, thick, draw=red, fill=red]
        (q1) edge node {a}   (q0)
        (q2) edge node {a} (q0);
    \end{tikzpicture}
    \hspace{4cm}
    \begin{tikzpicture} [node distance = 2cm, on grid, auto]
        
        \node (q0) [state, draw=green] {$j$};
        \node (q1) [state, draw=green, above right = of q0] {$i$};
        \node (q2) [state, draw=green, below right = of q0] {$k$};
        
        \path [-stealth, thick, draw=green, fill=green]
        (q1) edge node {a}   (q0)
        (q2) edge node {b} (q0);
    \end{tikzpicture}
    \caption{A gauche, un automate non-réversible et à droite, un automate réversible}
\end{figure}
    
%QUESTION 6
\section{Modélisation d'un automate fini complet avec au plus $l$ états en FNC}
\noindent Pour que l'automate fini complet ait au plus $l$ états, il suffit de rajouter aux contraintes de l'automate déterministe complet (cf. \ref{sec:automate_deterministe_complet}) 
la contrainte suivante (suivant le formalisme de la documentation de \href{https://pysathq.github.io/docs/html/api/solvers.html#pysat.solvers.Solver.add_atmost}{PySAT}):
\begin{enumerate}
    \item Il y a au plus $l$ états acceptants :
    \begin{equation*}
        \sum_{i=0}^{k} q_{ia} \le l
    \end{equation*}
\end{enumerate}
Cette contrainte a été ajoutée au solveur \texttt{MiniCard}.


%QUESTION 7
\section{Modélisation d'un automate non déterministe en FNC}
\label{sec:non_deterministe}
\noindent La principale différence entre un automate non-déterministe et un automate déterministe est qu'il n'y a plus un unique état $j$ accessible depuis un état $i$
après la lecture d'une lettre $l$ mais bien un ensemble d'états $J$ accessibles depuis un état $i$ après la lecture d'une lettre $l$. Les variables de transition deviennent
donc des relations. \\
De ce fait, les variables de transitions changent de définition :
\begin{equation*}
    \Delta = \{d_{i, l, J} | i\in Q, J\subseteq Q, l \in \Sigma\}
\end{equation*}
La contrainte ($\Phi_3$) qui émpêche d'avoir plusieurs transitions pour une même lettre $l$ depuis un état $i$ est donc supprimée. (cf. \ref{sub:contraintes})\\
Après plusieurs essais, nous ne voyons pas en quoi les contraintes précédemment définies ne permettent pas au solveur de trouver une solution pour les
contraintes en $FNC$.


%QUESTION 8
\section{Modélisation d'un automate avec au plus k états et k' transitions en FNC}
En suivant le raisonnement de la question 6, il suffirait de rajouter une contrainte au solveur \texttt{MiniCard} 
sur le nombre de transitions et faire en sorte que celui-ci ne dépasse pas $k'$.

\newpage
\section{Annexe}
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{../Fonda.pdf}
    \caption{Développement des raisonnements pour le projet}
    \label{fig:automate}
\end{figure}

%================= Bibliography ========================
% \newpage
% \phantomsection % Required if hyperref is used
% \addcontentsline{toc}{section}{References} % Adding bibliography to table of contents
% \printbibliography % Print the bibliography

\end{document}
